# Homework 0 - 3 & Graphics Pipeline(Real-time Rendering)

> 学习完第一章内容之后, 做了一下hw0-3, 实现了一个非常基本的图形学渲染pipeline, 对前面学习中遇到的问题也有了较为深入的理解, 在这里结合 Graphics Pipeline做一个小结.

## Graphics Pipeline

![linear](../images/games101_5/2%20(1).png){: width="600px" .center}

1. 首先, 我们将我们希望表达的3D物体表面分割成很多个三角形, 讲这些三角形的顶点作为输入.

2. 接着, 我们使用之前学习过的MVP(Model View Projection)变换, 将这些顶点从模型空间变换到屏幕空间.

3. 真实的三角形是连续的, 我们希望将其渲染在离散的像素屏幕上, 因此我们需要进行光栅化, 将三角形投影到屏幕上, 并确定哪些像素被三角形覆盖, 并且可以使用如MSAA的手段提升图像质量. 同时, 空间中可能有多个点会投影到同一个像素上, 我们需要决定使用哪个点的颜色, 这里就需要用到z-buffer.

4. 接下来, 对于每个像素, 我们可以使用Bing-Phong等着色模型对其进行着色, 当然也可以使用现成的纹理对其着色.

## Problems Solved

+ 我们假设相机放在坐标系原点, 看向-z方向, 那么我们的场景空间就可以被理解为以z轴为中心的空间(被z轴串起来), 如果是透视投影的情形, 场景的形状应当为一个棱台, 如果把它补全成棱锥的话, 顶点为原点(相机位置). 而后我们将棱台压缩为一个立方体, 在平移到原点, 放缩到[-1,1]的范围, 这样就得到了我们屏幕空间, 屏幕空间通过z-buffer进行深度测试, 确定哪些像素被覆盖, 并进行着色.

![linear](../images/games101_5/2%20(2).png){: width="600px" .center}

> 所以其实当相机位置摆好之后, 相机中心, 近平面中心, 远平面中心都在z轴上.

+ 老师上课时候推导整套Pipeline时, z方向的符号有点混乱, 在这里明确一下.

一开始的相机是朝向z轴负方向的, 所以传入的近平面参数$n$以及远平面参数$f$应当保证是负数, 代码框架中为正数, 需要取相反数. 经过透视投影之后, 需要进行z-buffer, 此时z值越大对应深度越大, 那么z应当是正数, 即需要我们再次将z取相反数, 即给投影矩阵再左乘一个变换矩阵即可:

$$
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & -1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

最后, 有一篇写的很好的[blog](https://blog.csdn.net/Q_pril/article/details/123598746), 基本cover了hw03中Pipeline的所有部分.